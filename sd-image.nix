{ config, pkgs, lib, modulesPath, ... }:

{
  options.hardware.zynq = {
    bitstream = lib.mkOption {
      type = lib.types.path;
      example = lib.literalExpression "./firmware/system.bit";
      description = lib.mdDoc ''
        Generation for bitstream from XSA file in Nix is not implemented yet.
        You need to provide the path to system.bit generated by Vitis.
        Can be semi-automated using {command}`./vitisgenfw.tcl <vivado_exported.xsa>`
      '';
    };
    fsbl = lib.mkOption {
      type = lib.types.path;
      example = lib.literalExpression "./firmware/fsbl_a53.elf";
      description = lib.mdDoc ''
        Generation for First Stage Boot Loader from XSA file in Nix is not implemented yet.
        You need to provide the path to fsbl_a53.elf generated by Vitis.
        Can be semi-automated using {command}`./vitisgenfw.tcl <vivado_exported.xsa>`
      '';
    };
    pmufw = lib.mkOption {
      type = lib.types.path;
      example = lib.literalExpression "./firmware/pmufw.elf";
      description = lib.mdDoc ''
        Generation for Zynq MPSoC Platform Management Unit Firmware from XSA file in Nix is not implemented yet.
        You need to provide the path to pmufw.elf generated by Vitis.
        Can be semi-automated using {command}`./vitisgenfw.tcl <vivado_exported.xsa>`
      '';
    };
    boot-bin = lib.mkOption {
      type = lib.types.path;
      default = pkgs.boot-bin-xlnx.override {
        inherit (config.hardware.zynq) bitstream fsbl pmufw;
        dtb = "${config.hardware.deviceTree.package}/system.dtb";
      };
      description = lib.mdDoc ''
        You can build BOOT.BIN without building the whole system using
        {command}`nix build .#nixosConfigurations.<hostname>.config.hardware.zynq.boot-bin`
      '';
    };
  };

  imports = [
    "${modulesPath}/profiles/base.nix"
    "${modulesPath}/installer/sd-card/sd-image.nix"
    ./nixos.nix
  ];
  disabledModules = [ "${modulesPath}/profiles/all-hardware.nix" ];

  config = {
    sdImage = {
      # Depending on the FSBL setup, BOOT.BIN can be quite large
      firmwareSize = 100;
      populateFirmwareCommands = ''
        cp ${config.hardware.zynq.boot-bin}/BOOT.BIN firmware/
      '';
      populateRootCommands = ''
        mkdir -p ./files/boot
        ${config.boot.loader.generic-extlinux-compatible.populateCmd} -c ${config.system.build.toplevel} -d ./files/boot
      '';
    };

    environment.systemPackages = [
      (pkgs.writeShellApplication {
        name = "xlnx-firmware-update";
        text = ''
          systemctl start boot-firmware.mount
          cp ${config.hardware.zynq.boot-bin}/BOOT.BIN /boot/firmware/
        '';
      })
    ];

    # Some modules aren't available...
    boot.initrd.includeDefaultModules = false;
    boot.initrd.availableKernelModules = [
      "ahci"
      "sata_inic162x"
      "sata_sil24"
      # NVMe
      "nvme"
      # Standard SCSI stuff.
      "sr_mod"
      # Support USB keyboards, in case the boot fails and we only have
      # a USB keyboard, or for LUKS passphrase prompt.
      "uhci_hcd"
      "ehci_hcd"
      "ehci_pci"
      "ohci_hcd"
      "ohci_pci"
      "xhci_hcd"
      "xhci_pci"
      "usbhid"
      "hid_generic" "hid_lenovo" "hid_apple" "hid_roccat"
      "hid_logitech_hidpp" "hid_logitech_dj" "hid_microsoft" "hid_cherry"
      # Broadcom
      "vc4"
    ];
  };
}

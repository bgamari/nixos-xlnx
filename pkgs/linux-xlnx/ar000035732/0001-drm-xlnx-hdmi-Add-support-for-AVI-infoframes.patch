# Copyright 2023, Advanced Micro Devices, Inc
# SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
# Downloaded from https://support.xilinx.com/s/article/000035732?language=en_US
From 7bb8d88bf360e72002cfbac44e987a113db0c827 Mon Sep 17 00:00:00 2001
From: Rajesh Gugulothu <rajesh.gugulothu@amd.com>
Date: Thu, 5 Oct 2023 18:26:14 +0530
Subject: [LINUX PATCH 1/5] drm: xlnx: hdmi: Add support for AVI infoframes

Various aspects of the current video stream are indicated by the
HDMI source to the sink with an Auxiliary Video information(AVI)
Infoframes. Source shall send the AVI to the sink once per video
field. The data from the AVI applies to the next full frame of the
video data.

Due to the lack of this support in the driver, YUV color formats
are not workring.

Signed-off-by: Rajesh Gugulothu <rajesh.gugulothu@amd.com>
---
 drivers/gpu/drm/xlnx/xlnx_hdmi.c | 152 ++++++++++++++++++++++++++++++-
 1 file changed, 150 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/xlnx/xlnx_hdmi.c b/drivers/gpu/drm/xlnx/xlnx_hdmi.c
index fc4b7bfeed60..f28c4603dd35 100644
--- a/drivers/gpu/drm/xlnx/xlnx_hdmi.c
+++ b/drivers/gpu/drm/xlnx/xlnx_hdmi.c
@@ -23,7 +23,7 @@
 #include <linux/workqueue.h>
 
 #include <uapi/linux/media-bus-format.h>
-
+#include <drm/display/drm_hdmi_helper.h>
 #include <drm/drm_atomic_helper.h>
 #include <drm/drm_connector.h>
 #include <drm/drm_crtc_helper.h>
@@ -344,6 +344,10 @@
 #define HDMI_MAX_WIDTH	10240
 #define HDMI_MAX_HEIGHT	4320
 
+#define HDMI_INFOFRAME_HEADER_TYPE(x)    (((x) & 0xff) <<  0)
+#define HDMI_INFOFRAME_HEADER_VERSION(x) (((x) & 0xff) <<  8)
+#define HDMI_INFOFRAME_HEADER_LEN(x)     (((x) & 0x0f) << 16)
+
 /**
  * enum hdmi_state - Stream state
  * @HDMI_TX_STATE_STREAM_DOWN: stream down
@@ -425,6 +429,11 @@ enum xlnx_hdmi_scdc_fields {
 	HDMI_TX_SCDC_FIELD_SIZE = 8
 };
 
+struct xlnx_hdmi_infoframe {
+	u32 header;
+	u32 data[8];
+};
+
 struct xlnx_hdmi_scdc_field {
 	u8 offset;
 	u8 msk;
@@ -522,6 +531,7 @@ struct xlnx_hdmi_stream {
  * @wait_event: Wait event
  * @bridge: bridge structure
  * @height_out: configurable bridge output height parameter
+ * @saved_adjusted_mode: Copy of @drm_crtc_state.adjusted_mode
  * @height_out_prop_val: configurable bridge output height parameter value
  * @width_out: configurable bridge output width parameter
  * @width_out_prop_val: configurable bridge output width parameter value
@@ -532,6 +542,7 @@ struct xlnx_hdmi_stream {
  * @txhdcp: Hdcp configuration
  * @hdcp_cp_irq_work: hdcp cp irq interrupt detection worker
  * @hdcp2x_timer_irq: hdcp2x timer interrupt
+ * @iframe: Infroframe pointer
  */
 struct xlnx_hdmi {
 	struct device *dev;
@@ -561,6 +572,7 @@ struct xlnx_hdmi {
 	struct drm_property *height_out;
 	u32 height_out_prop_val;
 	struct drm_property *width_out;
+	struct drm_display_mode saved_adjusted_mode;
 	u32 width_out_prop_val;
 	struct drm_property *in_fmt;
 	u32 in_fmt_prop_val;
@@ -569,6 +581,7 @@ struct xlnx_hdmi {
 	struct delayed_work hdcp_cp_irq_work;
 	struct xlnx_hdcptx txhdcp;
 	int hdcp2x_timer_irq;
+	struct xlnx_hdmi_infoframe *iframe;
 };
 
 enum xlnx_hdmitx_clks {
@@ -1503,6 +1516,131 @@ xlnx_hdmi_clkratio(struct xlnx_hdmi *hdmi)
 	return status;
 }
 
+static void xlnx_hdmi_avi_infoframe_colorspace(struct hdmi_avi_infoframe *frame,
+					       enum color_formats fmt)
+{
+	switch (fmt) {
+	case HDMI_TX_CSF_RGB:
+		frame->colorspace = HDMI_COLORSPACE_RGB;
+		break;
+	case HDMI_TX_CSF_YCRCB_420:
+		frame->colorspace = HDMI_COLORSPACE_YUV420;
+		break;
+	case HDMI_TX_CSF_YCRCB_422:
+		frame->colorspace = HDMI_COLORSPACE_YUV422;
+		break;
+	case HDMI_TX_CSF_YCRCB_444:
+		frame->colorspace = HDMI_COLORSPACE_YUV444;
+		break;
+	default:
+		break;
+	}
+}
+
+static void xlnx_hdmi_aux_write(struct xlnx_hdmi *hdmi, struct xlnx_hdmi_infoframe  *iframe)
+{
+	struct xlnx_hdmi_infoframe *infoframe = iframe;
+	u32 index, readval;
+
+	/* read the aux status register */
+	readval = xlnx_hdmi_readl(hdmi, HDMI_TX_AUX_STA);
+	/* First check if the AUX packet is ready */
+	if ((readval & (HDMI_TX_AUX_STA_PKT_RDY | HDMI_TX_AUX_STA_FL))) {
+		if (readval & HDMI_TX_AUX_STA_FL) {
+			readval = xlnx_hdmi_readl(hdmi, HDMI_TX_AUX_STA);
+			dev_dbg(hdmi->dev, "HDMI TX AUX FIFO full\n");
+		} else {
+			/* Update AUX with header data */
+			xlnx_hdmi_writel(hdmi, HDMI_TX_AUX_DAT,
+					 infoframe->header);
+			/* Update AUX with actual data */
+			for (index = 0x0; index < 8; index++) {
+				xlnx_hdmi_writel(hdmi, HDMI_TX_AUX_DAT,
+						 infoframe->data[index]);
+			}
+		}
+	}
+}
+
+/*
+ * Helper to concatenate infoframe in 32 bits word
+ *
+ * @ptr: pointer on the hdmi internal structure
+ * @size: size to write
+ */
+static inline unsigned int hdmi_infoframe_subpack(const u8 *ptr, size_t size)
+{
+	unsigned long value = 0;
+	size_t i;
+
+	for (i = size; i > 0; i--)
+		value = (value << 8) | ptr[i - 1];
+
+	return value;
+}
+
+static ssize_t xlnx_hdmi_setup_avi_infoframe(struct xlnx_hdmi *hdmi)
+{
+	struct xlnx_hdmi_infoframe infoframe;
+	struct hdmi_avi_infoframe frame;
+	u8 buffer[HDMI_INFOFRAME_SIZE(AVI)];
+	int ret, index = 0;
+	ssize_t err;
+	u32 val, i;
+	const u8 *ptr = buffer;
+
+	ret = drm_hdmi_avi_infoframe_from_display_mode(&frame,
+						       &hdmi->connector,
+						       &hdmi->saved_adjusted_mode);
+	if (ret < 0) {
+		dev_err(hdmi->dev, "couldn't fill AVI infoframe\n");
+		return ret;
+	}
+
+	xlnx_hdmi_avi_infoframe_colorspace(&frame, hdmi->xvidc_colorfmt);
+	err = hdmi_avi_infoframe_pack(&frame, buffer, sizeof(buffer));
+	if (err < 0) {
+		dev_err(hdmi->dev, "Failed to pack AVI infoframe: %zd\n", err);
+		return err;
+	}
+
+	val = HDMI_INFOFRAME_HEADER_TYPE(*ptr++);
+	val |= HDMI_INFOFRAME_HEADER_VERSION(*ptr++);
+	val |= HDMI_INFOFRAME_HEADER_LEN(*ptr++);
+	infoframe.header = val;
+
+	/*
+	 * Each subpack contains 4 bytes
+	 * The First Bytes of the first subpacket must contain the checksum
+	 * Packet size is increase by one.
+	 */
+
+	err = err - HDMI_INFOFRAME_HEADER_SIZE + 1;
+	for (i = 0; i < err; i += sizeof(u32)) {
+		size_t num;
+
+		num = min_t(size_t, err - i, sizeof(u32));
+		val = hdmi_infoframe_subpack(ptr, num);
+		ptr += sizeof(u32);
+		infoframe.data[index] = val;
+		index++;
+	}
+
+	xlnx_hdmi_aux_write(hdmi, &infoframe);
+
+	return 0;
+}
+
+static void xlnx_hdmi_send_infoframes(struct xlnx_hdmi *hdmi)
+{
+	xlnx_hdmi_setup_avi_infoframe(hdmi);
+}
+
+static void xlnx_hdmi_vsync_event_handler(struct xlnx_hdmi *hdmi)
+{
+	xlnx_hdmi_send_infoframes(hdmi);
+}
+
 /**
  * xlnx_hdmi_stream_start - set core parameters
  * @hdmi: pointer to HDMI TX core instance
@@ -2221,7 +2359,7 @@ static void xlnx_hdmi_piointr_handler(struct xlnx_hdmi *hdmi)
 			phy_cfg.hdmi.tx_params = 1;
 			phy_cfg.hdmi.ppc = hdmi->config.ppc;
 			phy_cfg.hdmi.bpc = hdmi->config.bpc;
-			phy_cfg.hdmi.fmt = HDMI_TX_CSF_RGB;
+			phy_cfg.hdmi.fmt = hdmi->xvidc_colorfmt;
 			phy_cfg.hdmi.tx_tmdsclk = hdmi->tmds_clk;
 			for (i = 0; i < HDMI_MAX_LANES; i++) {
 				ret = phy_configure(hdmi->phy[i], &phy_cfg);
@@ -2308,6 +2446,11 @@ static void xlnx_hdmi_piointr_handler(struct xlnx_hdmi *hdmi)
 	if (event & HDMI_TX_PIO_IN_BRIDGE_UFLOW)
 		dev_err_ratelimited(hdmi->dev, "Underflow interrupt\n");
 
+	/* vsync event has occurred */
+	if (event & HDMI_TX_PIO_IN_VS) {
+		dev_dbg_ratelimited(hdmi->dev, "Vsync interrupt\n");
+		xlnx_hdmi_vsync_event_handler(hdmi);
+	}
 	/* Link ready event has occurred */
 	if (event & HDMI_TX_PIO_IN_LNK_RDY) {
 		/* Check the link status */
@@ -2842,6 +2985,7 @@ xlnx_hdmi_encoder_atomic_mode_set(struct drm_encoder *encoder,
 	int ret, i;
 	u32 drm_fourcc, lnk_clk, vid_clk;
 
+	drm_mode_copy(&hdmi->saved_adjusted_mode, &crtc_state->adjusted_mode);
 	dev_dbg(hdmi->dev, "mode->clock = %d\n", mode->clock * 1000);
 	dev_dbg(hdmi->dev, "mode->crtc_clock = %d\n", mode->crtc_clock * 1000);
 	dev_dbg(hdmi->dev, "mode->pvsync = %d\n",
@@ -2908,6 +3052,10 @@ xlnx_hdmi_encoder_atomic_mode_set(struct drm_encoder *encoder,
 	hdmi->tmds_clk = adjusted_mode->clock * 1000;
 	dev_dbg(hdmi->dev, "tmds_clk = %u\n", hdmi->tmds_clk);
 
+	if (connector->display_info.is_hdmi) {
+		xlnx_hdmi_send_infoframes(hdmi);
+	}
+
 	if (hdmi->stream.is_frl) {
 		phy_cfg.hdmi.clkout1_obuftds = 1;
 		phy_cfg.hdmi.clkout1_obuftds_en = false;
-- 
2.17.1

